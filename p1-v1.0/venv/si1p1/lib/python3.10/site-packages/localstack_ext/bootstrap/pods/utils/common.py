_A=None
import json,logging,os,re,zipfile
from datetime import datetime
from typing import List,Optional
from localstack import config as localstack_config
from localstack_ext.bootstrap import auth
from localstack_ext.bootstrap.pods.constants import ASSETS_ROOT_DIR,COMPRESSION_FORMAT,DEFAULT_POD_DIR,OBJ_STORE_DIR,STATE_ZIP,VERSION_SPACE_DIRS,VERSIONS_ARCHIVE
LOG=logging.getLogger(__name__)
class PodsConfigContext:
	def __init__(A,pods_root_dir=_A,pod_name=_A):from localstack_ext.bootstrap.pods.object_storage import ObjectStorageProvider as B;A.cloud_pods_root_dir=pods_root_dir or A.get_pods_root_dir();A.pod_name=pod_name;A.user=_A;A.object_storage_provider=B(A)
	@property
	def pod_root_dir(self):
		A=self
		if not A.pod_name:raise Exception('Unable to determine pod root dir as pod name is not configured')
		return os.path.join(A.cloud_pods_root_dir,A.pod_name)
	@classmethod
	def get_pod_config_dir(A,pod_name):return os.path.join(A.get_pods_root_dir(),pod_name)
	@classmethod
	def get_pods_root_dir(B):
		A=localstack_config.CONFIG_DIR
		if localstack_config.is_in_docker:A=localstack_config.dirs.var_libs
		return os.environ.get('POD_DIR')or os.path.join(A,DEFAULT_POD_DIR)
	def get_pod_context(A):return os.path.basename(A.pod_root_dir)
	def get_context_user(A):return A.user
	def get_pod_root_dir(A):return A.pod_root_dir
	def get_obj_store_path(A):return os.path.join(A.pod_root_dir,OBJ_STORE_DIR)
	def get_assets_root_path(A):return os.path.join(A.pod_root_dir,ASSETS_ROOT_DIR)
	def get_pod_state_archive_path(C,version=_A):
		B=version;A=os.path.join(C.get_pod_root_dir(),STATE_ZIP)
		if B:A=f"{A}-{B}"
		return f"{A}.{COMPRESSION_FORMAT}"
	def get_pod_version_archive_path(C,version=_A):
		B=version;A=os.path.join(C.get_pod_root_dir(),VERSIONS_ARCHIVE)
		if B:A=f"{A}-{B}"
		return f"{A}.{COMPRESSION_FORMAT}"
	def is_initialized(A):return A.pod_root_dir and os.path.isdir(A.pod_root_dir)
	def get_max_version_number(B):
		A=B.object_storage_provider.get_available_versions()
		if A:return A[-1]
	def list_known_versions(A):return A.object_storage_provider.get_available_versions()
	def get_obj_file_path(A,key):return os.path.join(A.get_obj_store_path(),key)
	def set_pod_context(A,pod_name):
		B=pod_name;C=auth.get_auth_cache();D=C.get('username','unknown');A.pod_name=B
		if not os.path.isdir(A.pod_root_dir):raise Exception(f"Unable to find local cloud pod named '{B}'")
		A.user=D
	def pod_exists_locally(A,pod_name):return os.path.isdir(os.path.join(A.cloud_pods_root_dir,pod_name))
	def get_version_archive_dir_paths(A):return[os.path.join(A.get_pod_root_dir(),B)for B in VERSION_SPACE_DIRS]
def zip_file_paths(zip_dest,paths):
	B=zip_dest;from localstack.utils.archives import create_zip_file_python as C
	for A in paths:
		if os.path.isdir(A):C(content_root=os.path.basename(A),base_dir=A,zip_file=B,mode='a')
		elif os.path.isfile(A):add_file_to_archive(archive=B,file_path=A)
	return B
def add_file_to_archive(archive,file_path):
	A=file_path
	with zipfile.ZipFile(archive,'a')as B:B.write(A,os.path.basename(A))
def read_file_from_archive(archive_path,file_name):
	B=file_name;A=archive_path
	try:
		with zipfile.ZipFile(A)as C:D=json.loads(C.read(B));return json.dumps(D)
	except Exception as E:LOG.debug(f"Could not find {B} in archive {A}: {E}")
def is_comma_delimited_list(string):
	A=re.compile('^(\\w+)(,\\s*\\w+)*$')
	if A.match(string)is _A:return False
	return True
def convert_utc_timestamp_to_string(timestamp):
	try:return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')
	except TypeError:return''