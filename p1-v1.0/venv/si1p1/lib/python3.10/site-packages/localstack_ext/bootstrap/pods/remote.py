_E='presigned_urls'
_D='platform'
_C=None
_B=True
_A=False
import json,logging
from contextlib import contextmanager
from dataclasses import asdict,dataclass,field
from typing import Dict,Iterable,List,Optional,Set,TypedDict
from urllib.parse import quote,urlparse
from localstack import config,constants
from localstack.utils.collections import select_from_typed_dict
from localstack.utils.http import safe_requests
from localstack.utils.strings import to_str
from plugin import Plugin,PluginManager
from requests import Response
from localstack_ext.bootstrap import licensing
from localstack_ext.bootstrap.pods.fs import CloudPodsFileSystem
from localstack_ext.bootstrap.pods.remotes.api import CloudPodsRemotesClient
from localstack_ext.bootstrap.pods.utils.common import PodsConfigContext
LOG=logging.getLogger(__name__)
@dataclass
class RemoteConfig:remote_url:str
@dataclass
class RemoteConfigParams:
	remote_name:str;remote_params:dict[str,str]=field(default_factory=dict)
	def render_url(B,remote_url):
		A=remote_url
		if B.remote_params:C={A:quote(B or'')for(A,B)in B.remote_params.items()};A=A.format(**C)
		try:A.format()
		except Exception as D:raise Exception(f"Missing parameters for cloud pod remote URL template: {A}")from D
		return A
	def to_dict(A):return asdict(A)
	@classmethod
	def from_dict(A,params):return A(**params)
PODS_REMOTE_NAMESPACE='localstack.pods.remote'
class CloudPodsRemote(Plugin):
	namespace=PODS_REMOTE_NAMESPACE;name:str;protocols:Set[str];remote_config:RemoteConfig;pods_fs_ops:CloudPodsFileSystem
	def load(A,config_context,remote_config):A.pods_fs_ops=CloudPodsFileSystem(config_context);A.remote_config=remote_config
	def list_pods(A):raise NotImplementedError
	def get_max_version(A,pod_name):raise NotImplementedError
	def pull_version(A,pod_name,version):raise NotImplementedError
	def is_registered(A,pod_name):raise NotImplementedError
	def push_pod(A,pod_name,version,overwrite=_A,details=_C):raise NotImplementedError
	def register_remote(A,pod_name,details=_C):raise NotImplementedError
	def rename_pod(A,current_name,new_name):raise NotImplementedError
	def delete_pod(A,pod_name):raise NotImplementedError
	def get_remote_params(A):return{}
def create_platform_url(path=_C):
	A=path;B=f"{constants.API_ENDPOINT}/cloudpods"
	if not A:return B
	A=A if A.startswith('/')else f"/{A}";return f"{B}{A}"
def get_auth_headers():
	if not config.is_in_docker:return licensing.get_auth_headers()
	A=CloudPodsRemotesClient();return A.get_token()or{}
class CloudPod(TypedDict,total=_A):pod_name:str;max_version:int;last_change:Optional[int]
def get_unique_domains(presigned_urls):
	A=set()
	for B in presigned_urls.values():C=urlparse(B);A.add(C.netloc)
	return A
@contextmanager
def transparent_endpoint_injection_disabled_for(domains):
	C=domains
	try:
		try:
			from localstack.dns import server as A
			for B in C:A.exclude_from_resolution(B)
		except ImportError:LOG.debug('Cannot import DNS server - skipping modification to allow pod save')
		yield
	finally:
		from localstack.dns import server as A
		for B in C:A.revert_exclude_from_resolution(B)
class CloudPodsRemotePlatform(CloudPodsRemote):
	name=_D;protocols={_D}
	def get_max_version(B,pod_name):
		C=create_platform_url(pod_name);A=safe_requests.get(url=C,headers=get_auth_headers());D='Failed to get version information from platform.. aborting'
		if not B._check_response(A,message=D,raise_error=_B):return
		E=json.loads(A.content);F=int(E['max_version']);return F
	def pull_version(A,pod_name,version):
		B=version;D=create_platform_url(f"{pod_name}/data?version={B}");C=safe_requests.get(url=D,headers=get_auth_headers());E='Failed to pull requested version from platform (code <status_code>)'
		if not A._check_response(C,message=E,raise_error=_B):return
		A.pods_fs_ops.load_remote_cache(presigned_urls=C.json().get(_E),version=B)
	def push_pod(A,pod_name,version,overwrite=_A,details=_C):
		B=version;C=create_platform_url(f"{pod_name}/data?version={B}")
		if overwrite:C+='&overwrite=true'
		D=safe_requests.post(url=C,json=details,headers=get_auth_headers());F='Failed to get pre-signed URLs to upload new version: <content> (status <status_code>)'
		if not A._check_response(D,message=F,raise_error=_B):return
		G=json.loads(D.content);E=G.get(_E);H=get_unique_domains(E)
		with transparent_endpoint_injection_disabled_for(H):A.pods_fs_ops.upload_pod_to_pre_signed_urls(pre_signed_urls=E,version=B)
	def list_pods(B):C=create_platform_url();A=safe_requests.get(C,headers=get_auth_headers());B._check_response(A,message='Error fetching list of pods from API (status <status_code>)',raise_error=_B);A=json.loads(A.content);return[select_from_typed_dict(CloudPod,A)for A in A]
	def delete_pod(D,pod_name):
		B=pod_name;C=create_platform_url(B);A=safe_requests.delete(url=C,headers=get_auth_headers())
		if A.status_code==404:LOG.debug("Cloud Pod '%s' not found on platform",B);raise Exception(f"Cloud Pod '{B}' not found")
		if not A.ok:LOG.debug('Failed to delete cloud pod %s from platform (status code %s: %s)',B,A.status_code,A.content);raise Exception(A.content)
		return A.ok
	def is_registered(E,pod_name):
		A=pod_name
		try:B=create_platform_url(A);C=safe_requests.get(B,headers=get_auth_headers())
		except Exception as D:LOG.debug('An error occurred while checking remote management for pod "%s": "%s"',A,D);return _A
		return C.ok
	def register_remote(C,pod_name,details=_C):
		B=pod_name;A=details;E=create_platform_url(B);A=A or{};A.setdefault('pod_name',B);D=safe_requests.put(E,json=A,headers=get_auth_headers());F=f"Failed to register pod {B}: <content>"
		if not C._check_response(D,message=F):return _A
		G=json.loads(D.content);H=G.get(_E);C.pods_fs_ops.upload_pod_to_pre_signed_urls(pre_signed_urls=H,version=1);return _B
	def rename_pod(D,current_name,new_name):C=new_name;B=current_name;E=create_platform_url(f"{B}/rename");A={'new_pod_name':C};A=json.dumps(A);F=safe_requests.put(E,A,headers=get_auth_headers());G=f"Failed to rename {B} to {C}: <content>";return D._check_response(F,message=G)
	@classmethod
	def _check_response(C,response,message,raise_error=_A):
		B=response;A=message
		if B.ok:return _B
		if B.status_code in[401,403]:raise Exception('Access denied - please log in first.')
		A=A.replace('<content>',to_str(B.content));A=A.replace('<status_code>',str(B.status_code))
		if raise_error:raise Exception(A)
		LOG.warning(A);return _A
class CloudPodsRemoteManager(PluginManager[CloudPodsRemote]):
	protocols_to_plugin:Dict[str,Plugin]
	def __init__(A,**D):
		super().__init__(PODS_REMOTE_NAMESPACE,load_kwargs=D);A.protocols_to_plugin={};E=A.load_all()
		for C in E:
			F=C.protocols
			for B in F:
				if B in A.protocols_to_plugin:LOG.info('A plugin is already registered for protocol %s => overriding.',B)
				A.protocols_to_plugin[B]=C;LOG.debug('Mapping %s protocol to %s',B,C)
	def get_plugin_for_protocol(A,protocol):return A.protocols_to_plugin.get(protocol)
	def get_plugin_for_url(A,remote_url):B=urlparse(remote_url).scheme or _D;return A.get_plugin_for_protocol(protocol=B)