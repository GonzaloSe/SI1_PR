_K='Timeout exceed for the pod load operation. To avoid this issue, try to increase thevalue of the POD_LOAD_CLI_TIMEOUT configuration variable.'
_J='remote'
_I='localstack_version'
_H='No Cloud Pod instance detected in the local context - unable to add state'
_G='pod_name'
_F='description'
_E='size'
_D='services'
_C=True
_B=False
_A=None
import io,json,logging,os,zipfile
from abc import ABC,abstractmethod
from functools import singledispatch
from pathlib import Path
from typing import Any,Callable,Dict,List,Optional,Tuple,TypedDict
from urllib.parse import urlparse
import requests,yaml
from click import ClickException
from localstack import config
from localstack.cli import console
from localstack.constants import APPLICATION_JSON,HEADER_CONTENT_TYPE
from localstack.utils.files import load_file,new_tmp_file,rm_rf,save_file
from localstack.utils.http import download,safe_requests
from localstack.utils.strings import to_str
from requests.structures import CaseInsensitiveDict
from localstack_ext.bootstrap import licensing
from localstack_ext.bootstrap.pods.api_types import DEFAULT_STRATEGY,MergeStrategy
from localstack_ext.bootstrap.pods.constants import INTERNAL_REQUEST_PARAMS_HEADER
from localstack_ext.bootstrap.pods.fs import CloudPodsFileSystem
from localstack_ext.bootstrap.pods.remote import CloudPodsRemote,CloudPodsRemoteManager,RemoteConfig,RemoteConfigParams,create_platform_url
from localstack_ext.bootstrap.pods.remotes.api import CloudPodsRemotesClient
from localstack_ext.bootstrap.pods.service_state.service_state import ServiceState
from localstack_ext.bootstrap.pods.utils.adapters import ServiceStateMarshaller
from localstack_ext.bootstrap.pods.utils.common import PodsConfigContext
from localstack_ext.config import POD_LOAD_CLI_TIMEOUT
from localstack_ext.constants import API_PATH_PODS,API_STATES_DIR,ASSETS_DIRECTORY,CLOUDPODS_METADATA_FILE
LOG=logging.getLogger(__name__)
HEADER_LS_API_KEY='ls-api-key'
HEADER_LS_VERSION='ls-version'
HEADER_AUTHORIZATION='Authorization'
class PodInfo(TypedDict,total=_B):name:str;version:int;services:List[str];description:str;size:int;remote:str
def get_state_zip_from_instance(services=_A):
	B=services;C=f"{get_pods_endpoint()}/state";D=','.join(B)if B else'';E={INTERNAL_REQUEST_PARAMS_HEADER:'{}'};A=requests.get(C,params={_D:D},headers=E);F=PodInfo(services=A.headers.get('x-localstack-pod-services','').split(','),size=int(A.headers.get('x-localstack-pod-size',0)))
	if A.status_code>=400:raise Exception(f"Unable to get local pod state via management API {C} (code {A.status_code}): {A.content}")
	return A.content,F
class CloudPodsManager:
	pod_name:str;remote_config:Optional[RemoteConfig]
	def __init__(A,pod_name,remote_config=_A):B=pod_name;A.pod_name=B;A.remote_config=remote_config;C=PodsConfigContext(pod_name=B);A.pods_fs_ops=CloudPodsFileSystem(C)
	def init(A):A.pods_fs_ops.init(pod_name=A.pod_name)
	def _add_state_to_cloud_pods_store(B,content,extract_assets=_B):
		C=ServiceStateMarshaller.unmarshall(content,raw_bytes=_C)
		for(A,E)in C.state.items():
			for(F,G)in E.backends.items():B.pods_fs_ops.create_state_file_from_fs(file_name=F,service=A.service,region=A.region,root=API_STATES_DIR,account_id=A.account_id,object=G)
		if extract_assets:
			for(H,I)in C.assets.items():
				for(D,J)in I.items():B.pods_fs_ops.create_state_file_from_fs(rel_path=D,file_name=os.path.basename(D),service=H,region='NA',root=ASSETS_DIRECTORY,account_id='NA',object=J)
	def delete(A,remote):
		C=A.pods_fs_ops.config_context.cloud_pods_root_dir;B=os.path.join(C,A.pod_name)
		if os.path.isdir(B):rm_rf(B)
		if remote:return A.remote.delete_pod(A.pod_name)
		return _C
	def push(A,description=_A,services=_A,version=_A):
		J='version';D=version;C=description;A.pods_fs_ops.set_pod_context(A.pod_name);G=A.remote.is_registered(A.pod_name);E=D
		if not D:E=A.remote.get_max_version(A.pod_name)+1 if G else 1
		if not A.pods_fs_ops.config_context.is_initialized():LOG.debug(_H);return
		H,B=get_state_zip_from_instance(services=services);A._add_state_to_cloud_pods_store(content=H,extract_assets=_C);K=A.pods_fs_ops.config_context.get_pod_state_archive_path(version=E);save_file(K,H);F=A.pods_fs_ops.push(description=C,version=E)
		if G:I=D or F.version_number;L={_D:B.get(_D,[]),_E:B.get(_E,0),_F:C,_I:get_ext_version(),J:I};A.remote.push_pod(A.pod_name,version=I,details=L,overwrite=bool(D))
		LOG.debug("Created new version %s for pod '%s'",F.version_number,A.pod_name);B[J]=F.version_number;B['name']=A.pod_name
		if C:B[_F]=C
		B[_J]=A.remote.name;return B
	def pull(A,version=_A):
		B=version
		if B:
			C=A.remote.get_max_version(pod_name=A.pod_name)
			if B>C:raise Exception(f"Version {B} does not exist. The maximum one on remote is {C}")
		B=B or A.remote.get_max_version(A.pod_name)
		if A.pod_name not in A.pods_fs_ops.list_locally_available_pods():A.pods_fs_ops.init(pod_name=A.pod_name)
		A.pods_fs_ops.set_pod_context(A.pod_name);A._ensure_pod_version_content(version=B)
	def _ensure_pod_version_content(B,version):
		A=version;C=B.pods_fs_ops.config_context.get_pod_state_archive_path(version=A)
		if os.path.exists(C):LOG.debug('Version %s already available in the local cache',A);return
		LOG.debug(f"Pulling version {A} from remote");B.remote.pull_version(pod_name=B.pod_name,version=A)
	def commit(A,message=_A,services=_A):
		A.pods_fs_ops.set_pod_context(A.pod_name)
		if not A.pods_fs_ops.config_context.is_initialized():LOG.debug(_H);return
		B,D=get_state_zip_from_instance(services=services);A._add_state_to_cloud_pods_store(content=B);C=A.pods_fs_ops.commit(message=message);LOG.debug('Completed revision: %s',C.hash_ref)
	@staticmethod
	def deploy_pod_into_instance(pod_name,pod_version,pod_path):
		A=pod_path
		if not A:raise Exception(f"Unable to restore pod state via local pods management API: Pod Path {A} not valid")
		try:
			D=load_file(A,mode='rb');C=get_pods_endpoint();E={_G:pod_name,'pod_version':pod_version}
			try:B=requests.post(C,data=D,params=E,timeout=POD_LOAD_CLI_TIMEOUT)
			except requests.exceptions.Timeout as F:raise Exception(_K)from F
			if B.status_code>=400:raise Exception(f"Unable to restore pod state via local pods management API {C} (code {B.status_code}): {B.content}")
		except requests.exceptions.ReadTimeout:LOG.debug('Returning from cloud pod inject operation - continues to run in the background...')
	def inject(A,version=_A,merge_strategy=_A):
		C=merge_strategy;B=version;C=C or DEFAULT_STRATEGY
		if not A.pods_fs_ops.config_context.pod_exists_locally(A.pod_name):raise Exception(f"Unable to find a local version of pod {A.pod_name}")
		A.pods_fs_ops.set_pod_context(A.pod_name);B=B or A.remote.get_max_version(A.pod_name);D=A.pods_fs_ops.config_context.get_pod_state_archive_path(version=B)
		if not os.path.exists(D):raise Exception(f"Unable to find version {B} for cloud pod `{A.pod_name}` in the local cache")
		if C==MergeStrategy.OVERWRITE.value:LOG.debug('Merge strategy is %s. Resetting the state.',MergeStrategy.OVERWRITE.value);reset_state()
		try:LOG.debug(f"Injecting {D} for pod {A.pod_name}");A.deploy_pod_into_instance(pod_name=A.pods_fs_ops.config_context.pod_name,pod_version=B,pod_path=D)
		except Exception as E:LOG.debug('An exception occurred while trying to load Cloud Pod %s: "%s"',A.pod_name,E);return _B
		return _C
	def register_remote(A,details=_A):return A.remote.register_remote(A.pod_name,details=details)
	def list_pods(A):return A.remote.list_pods()
	@property
	def remote(self):
		A=self;D=CloudPodsRemoteManager(config_context=A.pods_fs_ops.config_context,remote_config=A.remote_config);B=''
		if A.remote_config and A.remote_config.remote_url:B=A.remote_config.remote_url
		C=D.get_plugin_for_url(remote_url=B)
		if not C:raise Exception(f"Unable to find remote implementation for URL '{B}'")
		return C
class PodConfigManagerMeta(type):
	def __getattr__(C,attr):
		def A(*D,**E):
			A=_A
			for F in C.CHAIN:
				try:
					B=getattr(F,attr)(*D,**E)
					if B:
						if not A:A=B
						elif isinstance(B,list)and isinstance(A,list):A.extend(B)
				except Exception:
					if LOG.isEnabledFor(logging.DEBUG):LOG.exception('error during PodConfigManager call chain')
			if A is not _A:return A
			raise Exception(f'Unable to run operation "{attr}" for local or remote configuration')
		return A
class PodConfigManager(metaclass=PodConfigManagerMeta):
	CHAIN=[]
	@classmethod
	def pod_config(D,pod_name):
		A=pod_name;C=PodConfigManager.list_pods();B=[B for B in C if B[_G]==A]
		if not B:raise Exception(f'Unable to find config for pod named "{A}"')
		return B[0]
def get_pods_manager(pod_name,remote_config=_A):return CloudPodsManager(pod_name=pod_name,remote_config=remote_config)
class CloudPodRemoteAttributes(TypedDict,total=_B):is_public:bool;description:Optional[str];services:Optional[List[str]]
class CloudPodsService(ABC):
	@abstractmethod
	def save(self,pod_name,attributes=_A,remote=_A,local=_B,version=_A):0
	@abstractmethod
	def delete(self,pod_name,remote=_A,delete_from_remote=_C):0
	@abstractmethod
	def load(self,pod_name,remote=_A,version=_A,merge_strategy=_A):0
	@abstractmethod
	def list(self,remote=_A):0
	@abstractmethod
	def get_versions(self,pod_name,remote=_A):0
	def get_metamodel(B,pod_name,version):
		A=requests.get(url=f"{get_pods_endpoint()}/state/metamodel",headers=_get_headers())
		if not A.ok:_raise_exception_with_formatted_message(f"Unable to get metamodel for pod {pod_name}",A)
		return json.loads(A.content)
	def set_remote_attributes(G,pod_name,attributes,remote=_A):
		D='is_public';C=remote;B=pod_name
		if C:LOG.debug(f"Trying to set attributes for remote '{C}'. Currently we support attributes only for the default remote");return
		E=create_platform_url(B);F=licensing.get_auth_headers();A=safe_requests.patch(E,headers=F,json={D:attributes[D]})
		if not A.ok:raise Exception(f"Error setting remote attributes for Cloud Pod {B} (code {A.status_code}): {A.text}")
def _get_headers():
	B={HEADER_CONTENT_TYPE:APPLICATION_JSON};C=CaseInsensitiveDict(licensing.get_auth_headers())
	for A in(HEADER_AUTHORIZATION,HEADER_LS_API_KEY,HEADER_LS_VERSION):
		if C.get(A):B[A]=C[A]
	return B
def _raise_exception_with_formatted_message(message,response):A=response;raise Exception(f"{message} (code {A.status_code}): {A.text}")
class CloudPodsClient(CloudPodsService):
	def save(E,pod_name,attributes=_A,remote=_A,local=_B,version=_A):
		D=version;C=pod_name;A=f"{get_pods_endpoint()}/{C}?"
		if local:A+='&local=true'
		if D:A+=f"&version={D}"
		F=E._get_remote_params_payload(remote);B=requests.post(url=A,json=F,headers=_get_headers())
		if not B.ok:_raise_exception_with_formatted_message(f"Unable to save pod {C}",B)
		G=json.loads(B.content);return G
	def delete(D,pod_name,remote=_A,delete_from_remote=_C):
		A=pod_name;B=f"{get_pods_endpoint()}/{A}"
		if not delete_from_remote:B+='?local=true'
		E=D._get_remote_params_payload(remote);C=requests.delete(url=B,json=E,headers=_get_headers())
		if not C.ok:_raise_exception_with_formatted_message(f"Unable to delete Cloud Pod '{A}'",C)
	def load(F,pod_name,remote=_A,version=_A,merge_strategy=_A):
		C=version;B=pod_name
		if C:
			A=requests.get(create_platform_url(B),headers=_get_headers())
			if not A.ok:_raise_exception_with_formatted_message(f"Unable to load pod {B}",A)
			D=int(json.loads(A.content)['max_version'])
			if C>D:raise Exception(f"Unable to load pod {B} with version {C}. The maximum version available in the remote storage is {D}")
		E=f"{get_pods_endpoint()}/{B}"
		if C:E+=f"?version={C}"
		G=F._get_remote_params_payload(remote);A=requests.put(url=E,json=G,headers=_get_headers())
		if not A.ok:_raise_exception_with_formatted_message(f"Unable to load pod {B}",A)
	def list(B,remote=_A):
		C=B._get_remote_params_payload(remote);A=requests.get(url=get_pods_endpoint(),json=C,headers=_get_headers())
		if not A.ok:_raise_exception_with_formatted_message('Unable to list Cloud Pods',A)
		return json.loads(A.content).get('cloudpods',[])
	def get_versions(C,pod_name,remote=_A):
		B=pod_name;D=C._get_remote_params_payload(remote);A=requests.get(url=f"{get_pods_endpoint()}/{B}/versions",json=D,headers=_get_headers())
		if A.status_code==404:raise Exception(f"Cloud Pod {B} not found")
		if not A.ok:_raise_exception_with_formatted_message(f"Unable to get versions for pod {B}",A)
		return json.loads(A.content).get('versions',[])
	def _get_remote_params_payload(E,remote):
		A=remote
		if not A:return{}
		C=_get_remote_configuration(A,render_params=_B);D=CloudPodsRemoteManager(config_context=_A,remote_config=_A);B=D.get_plugin_for_url(C.remote_url)
		if not B:return{}
		A.remote_params=B.get_remote_params();return{_J:A.to_dict()}
def _get_remote_configuration(params,render_params=_C):
	A=params;D=CloudPodsRemotesClient()
	try:C=D.get_remote(name=A.remote_name)
	except Exception as E:raise ClickException(f"Error getting configuration for the remote {A.remote_name}")from E
	B=C['remote_url']
	if render_params:B=A.render_url(B)
	LOG.debug('Remote configuration: %s',C);return RemoteConfig(remote_url=B)
class CloudPodsClientLegacy(CloudPodsService):
	def save(J,pod_name,attributes=_A,remote=_A,local=_B,version=_A):
		E=remote;C=pod_name;B=attributes;G=_get_remote_configuration(params=E)if E else _A;A=get_pods_manager(pod_name=C,remote_config=G)
		if not A.pods_fs_ops.config_context.is_initialized():A.init()
		A.pods_fs_ops.set_pod_context(pod_name=C);B=B or{};F=B.get(_F);D=A.push(description=F,services=B.get(_D));H=A.remote.is_registered(C)
		if not H and not local:I={_D:D.get(_D,[]),_E:D.get(_E,0),_F:F,_I:get_ext_version()};A.register_remote(details=I)
		return D
	def delete(E,pod_name,remote=_A,delete_from_remote=_C):B=remote;A=pod_name;LOG.debug("Deleting pod '%s'",A);C=_get_remote_configuration(params=B)if B else _A;D=get_pods_manager(pod_name=A,remote_config=C);D.delete(remote=delete_from_remote)
	def load(E,pod_name,remote=_A,version=_A,merge_strategy=_A,local=_B):B=version;A=remote;D=_get_remote_configuration(params=A)if A else _A;C=get_pods_manager(pod_name=pod_name,remote_config=D);C.pull(version=B);C.inject(version=B,merge_strategy=merge_strategy)
	def list(D,remote=_A):A=remote;B=_get_remote_configuration(params=A)if A else _A;C=get_pods_manager(pod_name='',remote_config=B);return C.list_pods()
	def get_versions(C,pod_name,remote=_A):A=CloudPodsClient();B=A.get_versions(pod_name=pod_name,remote=remote);return B
	def list_public_pods(E):
		B=create_platform_url('public');C=licensing.get_auth_headers();A=safe_requests.get(B,headers=C)
		if not A.ok:raise Exception(to_str(A.content))
		D=json.loads(A.content);return[A[_G]for A in D]
def get_pods_endpoint():A=config.get_edge_url();return f"{A}{API_PATH_PODS}"
class CloudPodsLocalService:
	def export_pod(I,target):
		C=target;G,D=get_state_zip_from_instance();E=urlparse(C);A=os.path.abspath(os.path.join(E.netloc,E.path));F=Path(A).parent.absolute()
		if not os.path.exists(F):raise Exception(f"{F} is not a valid path")
		save_file(file=A,content=G);B=get_environment_metadata();B['name']=os.path.basename(C);B.update(D)
		with zipfile.ZipFile(file=A,mode='a')as H:H.writestr(CLOUDPODS_METADATA_FILE,yaml.dump(B))
		return D
	def import_pod(H,source):
		C='pro';A=source;D=get_protocol_access(A);B=D(A);E=zipfile.ZipFile(io.BytesIO(B),'r');F=read_metadata_from_pod(E)or{};G=get_environment_metadata().get(C)
		if F.get(C,_B)and not G:console.print('Warning: You are trying to load a Cloud Pod generated with a Pro license.The loaded state might be incomplete.')
		return inject_pod_endpoint(content=B)
@singledispatch
def read_metadata_from_pod(zip_file):
	try:A=yaml.safe_load(zip_file.read(CLOUDPODS_METADATA_FILE));return A
	except KeyError:LOG.debug('No %s file in the archive',CLOUDPODS_METADATA_FILE)
@read_metadata_from_pod.register(bytes)
def _(zip_file):A=zip_file;A=zipfile.ZipFile(io.BytesIO(A),'r');return read_metadata_from_pod(A)
@read_metadata_from_pod.register(str)
def _(zip_file):
	with zipfile.ZipFile(zip_file)as A:return read_metadata_from_pod(A)
def inject_pod_endpoint(content):
	A=get_pods_endpoint()
	try:B=requests.post(A,data=content,timeout=POD_LOAD_CLI_TIMEOUT)
	except requests.exceptions.Timeout as C:raise Exception(_K)from C
	return B.ok
def get_environment_metadata():
	C=get_pods_endpoint();A=f"{C}/environment";B=requests.get(A)
	if not B.ok:raise Exception(f"Unable to retrieve environment metadata from {A}")
	return json.loads(B.content)
def get_git_base_url(user,repo):return f"https://raw.githubusercontent.com/{user}/{repo}/main"
def get_protocol_access(url):
	A=urlparse(url).scheme
	if A=='file':return get_zip_content_from_file
	elif A in['http','https']:return get_zip_content_from_http
	elif A=='git':return get_zip_content_from_git
	raise Exception(f"Protocol {A} not valid")
def get_zip_content_from_file(url):
	B=url;B=urlparse(B);A=os.path.abspath(os.path.join(B.netloc,B.path))
	if not os.path.exists(A):raise Exception(f"Path {A} does not exist")
	if not os.path.isfile(A):raise Exception(f"Path {A} is not a file")
	return load_file(A,mode='rb')
def get_zip_content_from_http(url):
	A=requests.get(url)
	if not A.ok:raise Exception(f"Unable to fetch Cloud Pod from URL {url} ({A.status_code}): {A.content}")
	return A.content
def get_zip_content_from_git(url):
	E=url[len('git://'):];A=E.split('/');F,G,H=A[0],A[1],A[2];I=f"{get_git_base_url(F,G)}";C=f"{I}/{H}";B=new_tmp_file()
	try:download(C,B);return load_file(B,mode='rb')
	except Exception as D:raise Exception(f"Failed to download Cloud Pod from URL {C}: {D}")from D
	finally:rm_rf(B)
def reset_state(services=_A):
	B=services
	def C(_url):
		A=requests.post(_url)
		if not A.ok:LOG.debug('Reset call to %s failed: status code %s',_url,A.status_code);raise Exception('Failed to reset LocalStack')
	if not B:A=f"{config.get_edge_url()}/_localstack/state/reset";C(A);return
	for D in B:A=f"{config.get_edge_url()}/_localstack/state/{D}/reset";C(A)
def get_ext_version():
	try:from localstack_ext import __version__ as A;return A
	except ImportError:return''