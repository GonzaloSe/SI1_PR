_C='state_archive_url'
_B='versions_archive_url'
_A=None
import hashlib,logging,os
from typing import List,Optional,Set,Tuple,TypedDict
from localstack.constants import TEST_AWS_ACCOUNT_ID
from localstack.utils.files import load_file,mkdir,rm_rf,save_file
from localstack.utils.http import download,safe_requests
from localstack.utils.strings import short_uid
from localstack_ext.bootstrap.pods.constants import NIL_PTR
from localstack_ext.bootstrap.pods.models import Commit,Revision,StateFileRef,Version
from localstack_ext.bootstrap.pods.object_storage import ObjectStorageProvider
from localstack_ext.bootstrap.pods.service_state.service_state import ServiceState
from localstack_ext.bootstrap.pods.service_state.service_state_types import BackendState,ServiceKey
from localstack_ext.bootstrap.pods.utils.common import PodsConfigContext,zip_file_paths
from localstack_ext.bootstrap.pods.utils.hash_utils import compute_revision_hash,random_hash
from localstack_ext.constants import API_STATES_DIR
LOG=logging.getLogger(__name__)
class CloudPodPreSignedUrls(TypedDict):state_archive_url:Optional[str];metadata_archive_url:Optional[str];versions_archive_url:Optional[str]
class CloudPodsFileSystem:
	config_context:PodsConfigContext;object_storage:ObjectStorageProvider
	def __init__(A,config_context):A.config_context=config_context;A.object_storage=ObjectStorageProvider(A.config_context)
	def init(A,pod_name=_A):
		B=pod_name;B=B or A.config_context.pod_name
		if A.config_context.pod_exists_locally(pod_name=B):LOG.debug('Pod with name %s already exists locally',B);return
		mkdir(A.config_context.get_pod_root_dir());A.config_context.set_pod_context(B);A._init_version();LOG.debug('Successfully initialized cloud pod under %s',A.config_context.get_pod_root_dir())
	def _init_version(A,version=_A):rm_rf(A.config_context.get_obj_store_path());mkdir(A.config_context.get_obj_store_path());B=random_hash();D=random_hash();E=Revision(hash_ref=B,parent_ptr=NIL_PTR,creator=A.config_context.get_context_user(),rid=short_uid(),revision_number=0,state_files=set());C=Version(hash_ref=D,parent_ptr=NIL_PTR,creator=A.config_context.get_context_user(),comment='Initial version',outgoing_revision_ptrs={B},incoming_revision_ptr=_A,state_files=set(),version_number=version);C.revisions.append(E);A.object_storage.upsert_objects(C)
	def commit(D,message=_A):
		A,B=D.get_latest_revision_of_active_version();C=compute_revision_hash(A,D.config_context.get_obj_store_path())
		if A.parent_ptr!=NIL_PTR:F=B.get_revision(A.parent_ptr);F.assoc_commit.head_ptr=C
		B.update_revision_key(old_key=A.hash_ref,new_key=C);A.hash_ref=C;E=Revision(hash_ref=random_hash(),state_files=set(),parent_ptr=C,creator=A.creator,rid=short_uid(),revision_number=A.revision_number+1);B.revisions.append(E);G=Commit(tail_ptr=A.hash_ref,head_ptr=E.hash_ref,message=message);A.assoc_commit=G;D.object_storage.upsert_objects(B);return A
	def load_remote_cache(A,presigned_urls,version):C=version;B=presigned_urls;D=B.get(_B);E=B.get(_C);F=A.config_context.get_pod_version_archive_path(version=C);download(url=D,path=F);G=A.config_context.get_pod_state_archive_path(version=C);download(url=E,path=G)
	def list_locally_available_pods(A):mkdir(A.config_context.cloud_pods_root_dir);B=[A for A in os.listdir(A.config_context.cloud_pods_root_dir)if not A.endswith('.json')];return B
	def push(B,description=_A,version=1):C=version;D,A=B.get_latest_revision_of_active_version();A.version_number=C;E=B._create_service_state_from_state_file_refs(state_file_refs=D.state_files);A.hash_ref=E.compute_hash_on_state();A.finalized=True;A.comment=description;F=Commit(tail_ptr=D.hash_ref,message='Finalizing commit');D.assoc_commit=F;B.object_storage.upsert_objects(A);B.create_version_archive(version=C);B._init_version(version=C+1);return A
	def set_pod_context(A,pod_name):A.config_context.set_pod_context(pod_name)
	def create_state_file_from_fs(C,file_name,service,region,root,account_id=_A,object=_A,rel_path=_A):
		E=region;D=service;A=account_id
		if A is _A:A=TEST_AWS_ACCOUNT_ID
		B=hashlib.sha1(object).hexdigest();F=C.config_context.get_obj_file_path(B);save_file(file=F,content=object);G=StateFileRef(hash_ref=B,rel_path=rel_path or f"{root}/{A}/{D}/{E}",file_name=file_name,size=len(object),service=D,region=E,account_id=A);C._add_state_file_to_expansion_point(G);return B
	def _get_state_file_path(B,key):
		A=B.config_context.get_obj_file_path(key)
		if os.path.isfile(A):return A
		LOG.warning(f"No state file with found with key: {key}")
	def _add_state_file_to_expansion_point(A,state_file):B=state_file;C,E=A.get_latest_revision_of_active_version();D=set(filter(lambda sf:not sf.congruent(B),C.state_files));D.add(B);C.state_files=D;A.object_storage.upsert_objects(E)
	def create_version_archive(A,version):B=A.config_context.get_pod_version_archive_path(version=version);rm_rf(B);C=zip_file_paths(zip_dest=B,paths=A.config_context.get_version_archive_dir_paths());return C
	def get_max_version(A):
		B=A.get_max_version_no()
		if B:return A.object_storage.get_in_progress_version()
	def get_max_version_no(A):return A.config_context.get_max_version_number()
	def get_latest_revision_of_active_version(B):A=B.object_storage.get_in_progress_version();C=A.get_latest_revision();return C,A
	def _create_service_state_from_state_file_refs(C,state_file_refs):
		A=ServiceState()
		for B in state_file_refs:
			D=B.rel_path.startswith(API_STATES_DIR)
			if D:E=C._create_backend_state_from_state_file(B);A.put_backend(E)
			else:C._add_assets_from_state_file(B,A)
		return A
	def _create_backend_state_from_state_file(B,state_file):A=state_file;C=ServiceKey(account_id=A.account_id,region=A.region,service=A.service);D=B.object_storage.get_state_file_location_by_key(A.hash_ref);E=load_file(file_path=D,mode='rb');return BackendState(key=C,backends={A.file_name:E})
	def _add_assets_from_state_file(B,state_file,service_state):A=state_file;C=B.object_storage.get_state_file_location_by_key(A.hash_ref);D=load_file(file_path=C,mode='rb');service_state.put_asset(service_name=A.service,asset_name=A.rel_path,asset_value=D)
	def set_active_version(A,version_no,commit_before=False):
		B=version_no;C=A.config_context.list_known_versions()
		for D in C:
			if D==B:
				if commit_before:A.commit()
				return True
		LOG.info(f"Version with number {B} not found");return False
	def get_version_by_number(A,version_no):
		B=version_no;C=A.config_context.list_known_versions()
		if B not in C:LOG.debug('Could not find version number %s',B);return
		return A.object_storage.get_in_progress_version()
	def list_versions(A):B=A.config_context.list_known_versions();C=[A.object_storage.get_in_progress_version()for B in B];return C
	def upload_pod_to_pre_signed_urls(A,pre_signed_urls,version):C=version;B=pre_signed_urls;D=B.get(_B);E=A.config_context.get_pod_version_archive_path(C);A._upload(D,E);F=B.get(_C);G=A.config_context.get_pod_state_archive_path(C);A._upload(F,G)
	@staticmethod
	def _upload(pre_signed_url,content_path):
		A=content_path
		if A is _A:return
		B=load_file(A,mode='rb')
		if not B:raise Exception(f"Cloud pod file {A} doesn't exist or is empty")
		upload_content(pre_signed_url,B)
def upload_content(pre_signed_url,zip_data_content):
	A=safe_requests.put(pre_signed_url,data=zip_data_content)
	if not A.ok:raise Exception(f"Unable to upload pod state to S3 (code {A.status_code}): {A.content}")