_R='curses'
_Q='url-or-name'
_P='version'
_O='description'
_N="Login to save to the Cloud Pod's platform"
_M='delete'
_L='services'
_K='url'
_J=False
_I='format_'
_H='--format'
_G='-f'
_F=True
_E='remote'
_D='table'
_C='name'
_B='json'
_A=None
import json,logging
from typing import Dict,List,Optional,Tuple
from urllib.parse import urlparse
import click,requests
from localstack import config
from localstack.cli import console
from localstack.cli.exceptions import CLIError
from localstack.utils.analytics.cli import publish_invocation
from localstack_ext import config as ext_config
from localstack_ext.bootstrap import licensing
from localstack_ext.bootstrap.pods.api_types import DEFAULT_STRATEGY,MergeStrategy
from localstack_ext.bootstrap.pods.remote import RemoteConfigParams
from localstack_ext.bootstrap.pods.remotes.api import CloudPodsRemotesClient
from localstack_ext.bootstrap.pods.utils.common import convert_utc_timestamp_to_string,is_comma_delimited_list
from localstack_ext.bootstrap.pods_client import CloudPodRemoteAttributes,CloudPodsClient,CloudPodsClientLegacy,CloudPodsLocalService,CloudPodsService
from localstack_ext.cli.click_utils import print_table
from localstack_ext.cli.tree_view import TreeRenderer
LOG=logging.getLogger(__name__)
def _assert_host_reachable():
	try:requests.get(config.get_edge_url())
	except requests.ConnectionError:raise CLIError('Destination host unreachable. Please make sure LocalStack is running.')
def _get_pod_client():
	if ext_config.ACTIVATE_NEW_POD_CLIENT:return CloudPodsClient()
	LOG.warning("The old Cloud Pods client is deprecated (since 2.3) and will be removed in the release 3.0 of LocalStack.You can still use the old client by setting the ACTIVATE_NEW_POD_CLIENT environment variable to '0'.");return CloudPodsClientLegacy()
@click.group(name='pod',help='Manage the state of your instance via Cloud Pods.',context_settings=dict(max_content_width=120))
def pod():0
@pod.group(name=_E,help='Manage cloud pod remotes')
def remote():0
@remote.command(name='add',short_help='Add a remote',help='\n    Add a new remote for Cloud Pods.\n\n    A remote is the place where your Cloud Pods are stored. By default, Cloud Pods are store in the LocalStack platform.\n    ')
@click.argument(_C,required=_F)
@click.argument(_K,required=_F)
def cmd_add_remote(name,url):
	A=name;_assert_host_reachable();C=CloudPodsRemotesClient();D=urlparse(url).scheme
	try:C.create_remote(name=A,protocols=[D],remote_url=url)
	except Exception as B:raise CLIError(f"Unable to determine URL for remote '{A}': {B}")from B
	console.print(f"Successfully added remote '{A}'")
@remote.command(name=_M,short_help='Delete a remote',help='Remove a remote for Cloud Pods.')
@click.argument(_C,required=_F)
def cmd_delete_remote(name):
	A=name;_assert_host_reachable();C=CloudPodsRemotesClient()
	try:C.delete_remote(name=A)
	except Exception as B:raise CLIError(f"Unable to delete remote '{A}': {B}")from B
	console.print(f"Successfully deleted remote '{A}'")
@remote.command(name='list',short_help='Lists the available remotes')
@click.option(_G,_H,_I,type=click.Choice([_D,_B]),default=_D,help='The formatting style for the remotes command output.')
def cmd_remotes(format_):
	_assert_host_reachable();B=CloudPodsRemotesClient();A=B.get_remotes()
	if not A:console.print('[yellow]No remotes[/yellow]');return
	if format_==_B:console.print_json(json.dumps(A));return
	print_table(column_headers=['Remote Name','URL'],columns=[[A[_C]for A in A],[A[_K]for A in A]])
@pod.command(name=_M,short_help='Delete a Cloud Pod',help='\n    Delete a Cloud Pod registered on the remote LocalStack platform.\n\n    This command will remove all the versions of a Cloud Pod, and the operation is not reversible.\n    ')
@click.argument(_C)
@publish_invocation
def cmd_pod_delete(name):
	A=name;C=_get_pod_client()
	try:C.delete(pod_name=A);console.print(f"Successfully deleted Cloud Pod '{A}'")
	except Exception as B:raise CLIError(f"Unable to delete Cloud Pod '{A}': {B}")from B
@pod.command(name='save',short_help='Create a new Cloud Pod',help="\n    Save the current state of the LocalStack container in a Cloud Pod.\n\n    A Cloud Pod can be exported locally or registered within the LocalStack platform (with a Pro license).\n    An optional message can be attached to any Cloud Pod.\n    Furthermore, one could decide to export only a subset of services with the optional --service option.\n\n    \x08\n    To export on a local path run the following command:\n    localstack pod save file://<path_on_disk>/<pod_name>\n\n    The output will be a <pod_name> zip file in the specified directory. This Cloud Pod instance can be restored at any\n    point in time with the load command.\n\n    To use the LocalStack platform for storage, the desired Cloud Pod's name will suffice, e.g.:\n\n    \x08\n    localstack pod save <pod_name>\n\n    Please be aware that each following save invocation with the same name will result in a new version being created.\n    ")
@click.argument(_Q)
@click.argument(_E,required=_J)
@click.option('-m','--message',help="Add a comment describing this Cloud Pod's version")
@click.option('-s','--services',help='Comma-delimited list of services to push in the Cloud Pod (all by default)')
@click.option('--visibility',type=click.Choice(['public','private']),help='Set the visibility of the Cloud Pod [`public` or `private`]. Does not create a new version')
@click.option(_G,_H,_I,type=click.Choice([_B]),help='The formatting style for the save command output.')
@publish_invocation
def cmd_pod_save(url_or_name=_A,url=_A,remote=_A,services=_A,message=_A,visibility=_A,format_=_A):
	H=format_;G=visibility;F=remote;D=services;A=url_or_name;I=_get_pod_client();_assert_host_reachable();K=urlparse(A).scheme=='file'
	if url or K:
		E=url or A;L=CloudPodsLocalService()
		try:
			C=L.export_pod(target=E)
			if H==_B:console.print_json(json.dumps(C))
			else:console.print(f"Cloud Pod `{E}` successfully exported ✅")
			return
		except Exception as B:raise CLIError(f"Failed to create Cloud Pod `{E}` ❌ - {B}")from B
	if not licensing.is_logged_in():raise CLIError(_N)
	if D and not is_comma_delimited_list(D):raise CLIError('Input the services as a comma-delimited list')
	J=RemoteConfigParams(remote_name=F)if F else _A
	if G:
		try:I.set_remote_attributes(pod_name=A,attributes=CloudPodRemoteAttributes(is_public=_F),remote=J)
		except Exception as B:raise CLIError(str(B))
		console.print(f"Cloud Pod {A} made {G}")
	M=[A.strip()for A in D.split(',')]if D else _A
	try:C=I.save(pod_name=A,attributes={_O:message,_L:M},remote=J)
	except Exception as B:raise CLIError(f"Failed to create Cloud Pod {A} ❌ - {B}")from B
	if H==_B:console.print_json(json.dumps(C))
	else:console.print(f"Cloud Pod `{A}` successfully created ✅\nVersion: {C[_P]}\nRemote: {C[_E]}\nServices: {','.join(C[_L])or'none'}")
@pod.command(name='load',help="\n    Load the state of a Cloud Pod into the application runtime\n\n    This command loads a Cloud Pod into the running LocalStack container.\n    Users can import Pods from different sources: community users can store and retrieve Pods from local storage\n    or any provided HTTP URL;\n    licensed users can take advantage of the LocalStack platform to ease the storage, versioning, and retrieval\n    of Cloud Pods.\n\n    The --source option specifies a URI scheme that points to the Cloud Pod's resources to import.\n\n    \x08\n    We support the following protocols:\n    localstack pod load file://<path_on_disk>\n    localstack pod load https://<some_url>\n    localstack pod load git://<user>/<repo>/<local_repo_path>\n\n    The latter option is merely a shortcut for --source https://raw.githubusercontent.com/<user>/<repo>/<branch>/<path>\n\n    Importing via a provided --source is available for all users.\n    Licensed users can omit this option and simply provide a name for their Cloud Pods.\n\n    Loading the state of a Cloud Pod into LocalStack might cause some conflicts with the current state of the container.\n    By default, LocalStack will attempt a best-effort merging strategy between the current state and the one from the\n    Cloud Pod. For a service X present in both the current state and the Cloud Pod, we will attempt to merge states\n    across different accounts and regions. If the service X has a state for the same account and region both in the\n    running container and the Cloud Pod, the latter will be used. If a service Y is present in the running container\n    but not in the Cloud Pod, it will be left untouched.\n    With `--merge overwrite`, the state of the Cloud Pod will completely replace the state of the running container.\n    ")
@click.argument(_Q)
@click.argument(_E,required=_J)
@click.option('--merge',type=click.Choice([A.value for A in MergeStrategy]),default=DEFAULT_STRATEGY,help='The merge strategy to adopt when loading the Cloud Pod')
@publish_invocation
def cmd_pod_load(url_or_name=_A,url=_A,remote=_A,merge=_A):
	C=remote;B=url;A=url_or_name;F=_get_pod_client();_assert_host_reachable();D=urlparse(B or A).scheme in['file','http','https','git']
	if not D and not licensing.is_logged_in():raise CLIError("It seems you are trying to access the Cloud Pod's platform.\nPlease login first.")
	if B or D:
		G=CloudPodsLocalService();H=G.import_pod(source=B or A)
		if H:console.print(f"Cloud Pod {A or B} successfully loaded");return
		else:raise CLIError(f"Failed to load Cloud Pod {A or B}")
	if not licensing.is_logged_in():raise CLIError(_N)
	try:I,J=get_pod_name_and_version(A);K=RemoteConfigParams(remote_name=C)if C else _A;F.load(pod_name=I,remote=K,version=J,merge_strategy=merge)
	except Exception as E:raise CLIError(f"Failed to load Cloud Pod {A or B}: {E}")from E
	print(f"Cloud Pod {A} successfully loaded")
def get_pod_name_and_version(pod_name):
	A=pod_name
	if':'not in A:return A,_A
	C,D,B=A.rpartition(':')
	if B.isdigit():return C,int(B)
	return A,_A
@pod.command(name='list',short_help='List all available Cloud Pods',help='\n    List all the Cloud Pods available for a single user, or for an entire organization, if the user is part of one.\n\n    With the --public flag, it lists the all the available public Cloud Pods. A public Cloud Pod is available across\n    the boundary of a user ond/or organization. In other words, any public Cloud Pod can be injected by any other\n    user holding a LocalStack Pro (or above) license.\n    ')
@click.argument(_E,required=_J)
@click.option('--public','-p',help='List all the available public Cloud Pods',is_flag=_F,default=_J)
@click.option(_G,_H,_I,type=click.Choice([_D,_B]),default=_D,help='The formatting style for the list pods command output.')
@publish_invocation
def cmd_pod_list_pods(remote=_A,public=_J,format_=_A):
	C='last_change';B=remote;D=_get_pod_client();_assert_host_reachable()
	if public:E=CloudPodsClientLegacy().list_public_pods();print_table(column_headers=['Cloud Pod'],columns=[E]);return
	F=RemoteConfigParams(remote_name=B)if B else _A;A=D.list(remote=F)
	if not A:console.print('[yellow]No pods available[/yellow]')
	if format_==_B:console.print_json(json.dumps(A));return
	print_table(column_headers=['Name','Max Version','Last Change'],columns=[[A['pod_name']for A in A],[str(A['max_version'])for A in A],[convert_utc_timestamp_to_string(A[C])if A.get(C)else'n/a'for A in A]])
@pod.command(name='versions',help='\n    List all available versions for a Cloud Pod\n\n    This command lists the versions available for a Cloud Pod.\n    Each invocation of the save command is going to create a new version for a named Cloud Pod, if a Pod with\n    such name already does exist in the LocalStack platform.\n    ')
@click.argument(_C)
@click.option(_G,_H,_I,type=click.Choice([_D,_B]),default=_D,help='The formatting style for the version command output.')
@publish_invocation
def cmd_pod_versions(name,format_):
	C=_get_pod_client();_assert_host_reachable()
	try:A=C.get_versions(pod_name=name)
	except Exception as B:raise CLIError(str(B))from B
	if not A:console.print('[yellow]No versions available[/yellow]')
	if format_==_B:console.print_json(json.dumps(A));return
	print_table(column_headers=['Version','Creation Date','LocalStack Version','Services','Description'],columns=[[str(A[_P])for A in A],[convert_utc_timestamp_to_string(A['created_at'])for A in A],[A['localstack_version']for A in A],[','.join(A[_L]or[])for A in A],[A[_O]for A in A]])
@pod.command(name='inspect',help='\n    Inspect the contents of a Cloud Pod\n\n    This command shows the content of a Cloud Pod.\n    By default, it starts a curses interface which allows an interactive inspection of the contents in the Cloud Pod.\n')
@click.argument(_C)
@click.option(_G,_H,_I,type=click.Choice([_R,'rich',_B]),default=_R,help='The formatting style for the inspect command output.')
@publish_invocation
def cmd_pod_inspect(name,format_):
	B=_get_pod_client()
	try:A=B.get_metamodel(pod_name=name,version=-1)
	except Exception:raise CLIError('Error occurred while fetching the metamodel')
	C=['cloudwatch']
	for(D,E)in A.items():A[D]={A:B for(A,B)in E.items()if A not in C}
	TreeRenderer.get(format_).render_tree(A)
def get_pods_community_commands():A=click.Group(name='pod',help='Manage the state of your instance via Cloud Pods. Run `localstack login` for using remote pod operations.',context_settings=dict(max_content_width=120));[A.add_command(B)for B in community_pods_commands];cmd_pod_save.params=list(filter(lambda x:isinstance(x,click.Argument),cmd_pod_save.params));cmd_pod_save.params=[cmd_pod_save.params[0]];cmd_pod_save.params[0].name=_K;cmd_pod_save.short_help='Create a new Cloud Pod and saves it to disk';cmd_pod_save.help='\n    Save the current state of the LocalStack container in a Cloud Pod.\n    To export on a local path run the following command:\n\n    localstack pod save file://<path_on_disk>/<pod_name>\n\n    The output will be a <pod_name> zip file in the specified directory. This Cloud Pod instance can be restored at any\n    point in time with the load command.\n    ';cmd_pod_load.params=list(filter(lambda x:isinstance(x,click.Argument),cmd_pod_load.params));cmd_pod_load.params=[cmd_pod_load.params[0]];cmd_pod_load.params[0].name=_K;cmd_pod_load.short_help='Load the state of a Cloud Pod into the application runtime from a given URL';cmd_pod_load.help="\n    Load a Cloud Pod into the running LocalStack container. Users can import Pods from different sources, i.e., local\n    storage or any provided HTTP URL.\n\n    Use the URL argument to specify the URL where the Cloud Pod's content is stored.\n\n    \x08\n    We support the following protocols:\n    localstack pod load file://<path_to_disk>\n    localstack pod load https://<some_url>\n    localstack pod load git://<user>/<repo>/<local_repo_path>\n\n    The latter option is merely a shortcut for:\n    \x08\n    localstack pod load https://raw.githubusercontent.com/<user>/<repo>/<branch>/<path>\n\n    Importing via a provided a given URL is available to all users.\n    ";return A
community_pods_commands=[cmd_pod_save,cmd_pod_load]